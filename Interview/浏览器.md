# 浏览器工作原理

## 从输入URL到页面加载完成

1. 输入url
2. 浏览器根据 DNS 服务器得到域名的 IP 地址
3. 向这个 IP 的机器发送 HTTP 请求
4. 服务器收到、处理并返回 HTTP 请求
5. 浏览器得到返回内容

## 浏览器渲染过程

1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树
2. 将DOM树和CSSOM树结合，生成渲染树(Render Tree)
3. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
4. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. Display:将像素发送给GPU，展示在页面上

### 回流和重绘

* 重绘：元素样式的改变（但宽高、大小、位置等不变）
* 回流：元素的大小或者位置发生改变（当页面布局和几何信息发生改变的时候），触发了重新布局导致渲染树重新计算布局和渲染

* 何时发生回流重绘：
  `回流一定会触发重绘，而重绘不一定会回流`

1. 添加或删除可见的DOM元素
2. 元素的位置发生变化
3. 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
4. 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
5. 页面一开始渲染的时候（这肯定避免不了）
6. 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

## 浏览器缓存

减少不必要的数据请求

区别:

1. 生命周期不同  
cookie：一般由服务器生成，可设置失效时间，如果在浏览器端生成cookie，默认是关闭后失效
localStorage：除非手动删除，否则永久保存
sessionStorage：仅在当前会话会有效，关闭页面或浏览器后被清除

2. 存放数据的大小不同
cookie：一般为4k
localStorage和sessionStorage：一般为5M

3. 与服务器端通信不同
cookie：每次都会自动加在请求头中，如果使用cookie保存过多数据会带来性能问题
localStorage和sessionStorage：仅在浏览器中保存，不参与和服务器的通信

4. 易用性
cookie：需要程序员自己来封装，原生的cookie接口不够友好
localStorage和sessionStorage：原生接口可以接受，可以封装来对Object和Array有更好的支持

## 跨域

1. 什么是同源策略及其限制内容
  
   * 同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击
   * 所谓同源是指`协议 + 域名 + 端口`三者相同

2. 同源策略限制内容有

   * Cookie、LocalStorage、IndexedDB 等存储性内容
   * DOM 节点
   * AJAX 请求发送后，结果被浏览器拦截了
   * 但是有三个标签是允许跨域加载资源`<img src='xxx'>` `<link href='xxx'>` `<script src='xxx'>`
   * 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了

3. cors
  服务端设置 `Access-Control-Allow-Origin` 就可以开启 `CORS`， 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源

4. jsonp
  利用`<script>`标签没有跨域限制的漏洞，缺点是仅支持get方法具有局限性, 不安全可能会遭受XSS攻击

5. node中间件代理(两次跨域)
  实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 代理服务器，需要做以下几个步骤：

    * 接受客户端请求
    * 将请求转发给服务器
    * 拿到服务器响应数据
    * 将响应转发给客户端

## 浏览器安全

1. XSS（跨站脚本攻击）
  黑客向页面插入一段恶意的js脚本，窃取用户隐私信息、修改web页面以欺骗用户、冒充用户进行操作

    * 反射型：恶意js脚本存在url里，属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行
    * 基于DOM型：网页本身的js也是可以改变HTML的，黑客正是利用这一点来实现插入恶意脚本
    * 存储型：存储到数据库后读取时注入

2. CSRF（跨站请求伪造）
  黑客引诱用户打开黑客的网站，利用用户的登陆状态发起跨站请求

    * 最容易实现的是 Get 请求，一般进入黑客网站后，可以通过设置 img的 src 属性来自动发起请求
    * 在黑客的网站中，构造隐藏表单来自动发起 Post 请求
    * 通过引诱链接诱惑用户点击触发请求，利用 a 标签的 href

3. XSS防御
    * 一切用户输入皆不可信，在输出时进行验证
    * 设置cookie的`HttpOnly`，document.cookie就不能获取到cookie
    * 将HTML元素内容和属性、URL请求参数、CSS值进行`编码`
    * 使用`CSP（内容安全策略）`，定义域名白名单

4. CSRF防御
    * 涉及到数据修改操作严格使用`post`请求而不是`get`请求
    * HTTP协议中使用`Referer`属性来确定请求来源进行过滤（禁止外域）
    * 请求地址添加`token`，使黑客无法伪造用户请求
    * 显示验证方式：添加验证码、密码等

## 垃圾回收

* 闭包以及内存泄漏
  